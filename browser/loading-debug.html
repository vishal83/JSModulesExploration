<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âš¡ Loading Demo Debug</title>
    <link rel="stylesheet" href="/browser/css/design-system.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ Loading Demo Debug Tool</h1>
            <p>Debug and analyze module loading behavior patterns</p>
        </div>
        
        <nav class="nav">
            <a href="/" class="nav-link">ğŸ  Home</a>
            <a href="/loading-demo" class="nav-link">âš¡ Loading Demo</a>
            <a href="/browser/debug.html" class="nav-link">ğŸ”§ Main Debug</a>
            <a href="https://github.com/vishal83/JSModulesExploration" target="_blank" class="nav-link">ğŸ“š GitHub</a>
        </nav>
        
        <div class="demo-section">
            <h2>ğŸ” Loading Pattern Analysis</h2>
            <p>Debug different module loading patterns and their behavior:</p>
            
            <button onclick="debugStaticImports()" class="btn btn-primary">Debug Static Imports</button>
            <button onclick="debugDynamicImports()" class="btn btn-success">Debug Dynamic Imports</button>
            <button onclick="debugLoadingOrder()" class="btn btn-secondary">Debug Loading Order</button>
            
            <div id="loading-debug-output" class="output">
ğŸ” Loading Debug Tool Ready!

Select a debug option above to analyze module loading patterns.
            </div>
        </div>
        
        <div class="demo-section">
            <h2>ğŸ“Š Performance Analysis</h2>
            <p>Measure and compare loading performance:</p>
            
            <button onclick="measureSequentialLoading()" class="btn btn-primary">Measure Sequential</button>
            <button onclick="measureParallelLoading()" class="btn btn-success">Measure Parallel</button>
            <button onclick="compareLoadingMethods()" class="btn btn-outline">Compare Methods</button>
            
            <div id="performance-debug-output" class="output">
ğŸ“Š Performance analysis tools ready for testing module loading speeds.
            </div>
        </div>
        
        <div class="info-box">
            <h3>ğŸ› ï¸ Debug Capabilities</h3>
            <ul>
                <li><strong>Static Import Analysis:</strong> Examine how static imports work</li>
                <li><strong>Dynamic Import Debugging:</strong> Test runtime module loading</li>
                <li><strong>Loading Order:</strong> Understand module execution order</li>
                <li><strong>Performance Measurement:</strong> Compare loading strategies</li>
                <li><strong>Network Analysis:</strong> Monitor HTTP requests</li>
            </ul>
        </div>
    </div>
    
    <script type="module">
        console.log('âš¡ Loading debug tool initialized');
        
        window.debugStaticImports = function() {
            const output = document.getElementById('loading-debug-output');
            output.className = 'output info';
            
            let debug = 'ğŸ“¦ Static Imports Debug Analysis:\n\n';
            debug += 'ğŸ” This page uses static imports at the top level:\n';
            debug += '  â€¢ All imports are hoisted\n';
            debug += '  â€¢ Modules load in parallel\n';
            debug += '  â€¢ Execution waits for all imports\n\n';
            
            debug += 'ğŸŒ Network Behavior:\n';
            debug += '  â€¢ Browser requests all modules immediately\n';
            debug += '  â€¢ HTTP/2 multiplexing enables parallel downloads\n';
            debug += '  â€¢ Module resolution happens at parse time\n\n';
            
            debug += 'âš¡ Execution Order:\n';
            debug += '  1. HTML parsed, <script type="module"> found\n';
            debug += '  2. JavaScript parsed, imports discovered\n';
            debug += '  3. All imports requested in parallel\n';
            debug += '  4. Script execution waits for imports\n';
            debug += '  5. Script body executes\n\n';
            
            debug += 'ğŸ’¡ Check Network tab to see the actual requests!';
            
            output.textContent = debug;
        };
        
        window.debugDynamicImports = async function() {
            const output = document.getElementById('loading-debug-output');
            output.className = 'output info';
            output.textContent = 'ğŸ”„ Testing dynamic imports...';
            
            try {
                let debug = 'ğŸ”„ Dynamic Imports Debug Results:\n\n';
                
                // Test dynamic import timing
                console.time('Dynamic Import Test');
                const startTime = performance.now();
                
                const mathModule = await import('/esm/math-utils.js');
                
                const endTime = performance.now();
                console.timeEnd('Dynamic Import Test');
                
                debug += `â±ï¸ Timing Results:\n`;
                debug += `  â€¢ Import duration: ${(endTime - startTime).toFixed(2)}ms\n`;
                debug += `  â€¢ Module: /esm/math-utils.js\n`;
                debug += `  â€¢ Exports loaded: ${Object.keys(mathModule).length}\n\n`;
                
                debug += `ğŸ” Dynamic Import Characteristics:\n`;
                debug += `  â€¢ Returns a Promise\n`;
                debug += `  â€¢ Loads at runtime (not parse time)\n`;
                debug += `  â€¢ Can be conditional\n`;
                debug += `  â€¢ Enables code splitting\n\n`;
                
                debug += `ğŸ§ª Test Results:\n`;
                debug += `  â€¢ add(10, 5) = ${mathModule.add(10, 5)}\n`;
                debug += `  â€¢ Module cached: ${performance.getEntriesByName('/esm/math-utils.js').length > 0}\n\n`;
                
                debug += `ğŸ’¡ Dynamic imports are perfect for:\n`;
                debug += `  â€¢ Lazy loading\n`;
                debug += `  â€¢ Conditional loading\n`;
                debug += `  â€¢ Code splitting\n`;
                debug += `  â€¢ Reducing initial bundle size`;
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `âŒ Dynamic import debug failed: ${error.message}`;
            }
        };
        
        window.debugLoadingOrder = async function() {
            const output = document.getElementById('loading-debug-output');
            output.className = 'output info';
            output.textContent = 'ğŸ“‹ Testing loading order...';
            
            try {
                let debug = 'ğŸ“‹ Module Loading Order Debug:\n\n';
                
                debug += 'ğŸ”„ Loading modules in sequence to observe order:\n';
                
                console.log('ğŸ“¦ Loading math module...');
                const mathStart = performance.now();
                await import('/esm/math-utils.js');
                const mathEnd = performance.now();
                debug += `  1. Math module: ${(mathEnd - mathStart).toFixed(2)}ms\n`;
                
                console.log('ğŸ‘¥ Loading user module...');
                const userStart = performance.now();
                await import('/esm/user-service.js');
                const userEnd = performance.now();
                debug += `  2. User module: ${(userEnd - userStart).toFixed(2)}ms\n`;
                
                console.log('âš™ï¸ Loading config module...');
                const configStart = performance.now();
                await import('/esm/config.js');
                const configEnd = performance.now();
                debug += `  3. Config module: ${(configEnd - configStart).toFixed(2)}ms\n\n`;
                
                debug += 'âš¡ Parallel Loading Test:\n';
                const parallelStart = performance.now();
                await Promise.all([
                    import('/esm/math-utils.js'),
                    import('/esm/user-service.js'),
                    import('/esm/config.js')
                ]);
                const parallelEnd = performance.now();
                debug += `  â€¢ Parallel time: ${(parallelEnd - parallelStart).toFixed(2)}ms\n\n`;
                
                debug += 'ğŸ” Key Observations:\n';
                debug += '  â€¢ Second imports of same module are instant (cached)\n';
                debug += '  â€¢ Parallel loading is faster than sequential\n';
                debug += '  â€¢ Module instances are singletons\n';
                debug += '  â€¢ Import order affects execution timing\n\n';
                
                debug += 'ğŸ’¡ Check console for detailed loading logs!';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `âŒ Loading order debug failed: ${error.message}`;
            }
        };
        
        window.measureSequentialLoading = async function() {
            const output = document.getElementById('performance-debug-output');
            output.className = 'output info';
            output.textContent = 'ğŸ“Š Measuring sequential loading...';
            
            try {
                const modules = ['/esm/math-utils.js', '/esm/user-service.js', '/esm/config.js'];
                
                console.time('Sequential Loading Measurement');
                const startTime = performance.now();
                
                const results = [];
                for (const modulePath of modules) {
                    const moduleStart = performance.now();
                    await import(modulePath);
                    const moduleEnd = performance.now();
                    results.push({
                        path: modulePath.split('/').pop(),
                        time: moduleEnd - moduleStart
                    });
                }
                
                const totalTime = performance.now() - startTime;
                console.timeEnd('Sequential Loading Measurement');
                
                let debug = 'ğŸ“Š Sequential Loading Performance:\n\n';
                debug += 'â±ï¸ Individual Module Times:\n';
                results.forEach((result, index) => {
                    debug += `  ${index + 1}. ${result.path}: ${result.time.toFixed(2)}ms\n`;
                });
                
                debug += `\nğŸ¯ Total Sequential Time: ${totalTime.toFixed(2)}ms\n\n`;
                
                debug += 'ğŸ” Sequential Characteristics:\n';
                debug += '  â€¢ Each module waits for previous to complete\n';
                debug += '  â€¢ Network requests happen one at a time\n';
                debug += '  â€¢ Predictable execution order\n';
                debug += '  â€¢ Higher total latency\n';
                debug += '  â€¢ Simpler error handling';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `âŒ Sequential measurement failed: ${error.message}`;
            }
        };
        
        window.measureParallelLoading = async function() {
            const output = document.getElementById('performance-debug-output');
            output.className = 'output info';
            output.textContent = 'ğŸ“Š Measuring parallel loading...';
            
            try {
                const modules = ['/esm/math-utils.js', '/esm/user-service.js', '/esm/config.js'];
                
                console.time('Parallel Loading Measurement');
                const startTime = performance.now();
                
                await Promise.all(modules.map(path => import(path)));
                
                const totalTime = performance.now() - startTime;
                console.timeEnd('Parallel Loading Measurement');
                
                let debug = 'ğŸ“Š Parallel Loading Performance:\n\n';
                debug += `ğŸ¯ Total Parallel Time: ${totalTime.toFixed(2)}ms\n\n`;
                
                debug += 'ğŸ” Parallel Characteristics:\n';
                debug += '  â€¢ All modules load simultaneously\n';
                debug += '  â€¢ Network requests happen concurrently\n';
                debug += '  â€¢ Utilizes HTTP/2 multiplexing\n';
                debug += '  â€¢ Lower total latency\n';
                debug += '  â€¢ Requires Promise.all() coordination\n\n';
                
                debug += 'ğŸŒ Network Benefits:\n';
                debug += '  â€¢ Reduces round-trip delays\n';
                debug += '  â€¢ Better bandwidth utilization\n';
                debug += '  â€¢ Ideal for independent modules\n';
                debug += '  â€¢ Modern browser optimization';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `âŒ Parallel measurement failed: ${error.message}`;
            }
        };
        
        window.compareLoadingMethods = async function() {
            const output = document.getElementById('performance-debug-output');
            output.className = 'output info';
            output.textContent = 'ğŸ“Š Comparing loading methods...';
            
            try {
                const modules = ['/esm/math-utils.js', '/esm/user-service.js', '/esm/config.js'];
                
                // Sequential test
                console.time('Sequential Comparison');
                const seqStart = performance.now();
                for (const path of modules) {
                    await import(path);
                }
                const seqTime = performance.now() - seqStart;
                console.timeEnd('Sequential Comparison');
                
                // Wait a bit to avoid interference
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Parallel test  
                console.time('Parallel Comparison');
                const parStart = performance.now();
                await Promise.all(modules.map(path => import(path)));
                const parTime = performance.now() - parStart;
                console.timeEnd('Parallel Comparison');
                
                const improvement = ((seqTime - parTime) / seqTime * 100).toFixed(1);
                
                let debug = 'ğŸ“Š Loading Method Comparison Results:\n\n';
                debug += 'âš¡ Performance Metrics:\n';
                debug += `  â€¢ Sequential Loading: ${seqTime.toFixed(2)}ms\n`;
                debug += `  â€¢ Parallel Loading: ${parTime.toFixed(2)}ms\n`;
                debug += `  â€¢ Performance Gain: ${improvement}% faster\n\n`;
                
                debug += 'ğŸ¯ Winner: ';
                if (parTime < seqTime) {
                    debug += 'Parallel Loading âœ…\n\n';
                } else {
                    debug += 'Sequential Loading (unusual!) âš ï¸\n\n';
                }
                
                debug += 'ğŸ“ˆ Analysis:\n';
                debug += `  â€¢ Time saved: ${(seqTime - parTime).toFixed(2)}ms\n`;
                debug += `  â€¢ Efficiency ratio: ${(parTime / seqTime).toFixed(2)}x\n`;
                debug += `  â€¢ Module count: ${modules.length}\n`;
                debug += `  â€¢ Network optimization: ${parTime < seqTime ? 'Effective' : 'Limited'}\n\n`;
                
                debug += 'ğŸ’¡ Recommendations:\n';
                if (improvement > 20) {
                    debug += '  â€¢ Use parallel loading for independent modules\n';
                    debug += '  â€¢ Significant performance benefit observed\n';
                } else {
                    debug += '  â€¢ Limited performance difference\n';
                    debug += '  â€¢ Either approach is acceptable\n';
                }
                debug += '  â€¢ Consider module dependencies\n';
                debug += '  â€¢ Use sequential for dependent modules';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `âŒ Comparison failed: ${error.message}`;
            }
        };
        
        console.log('âš¡ Loading debug script loaded and ready!');
    </script>
</body>
</html>