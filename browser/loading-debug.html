<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° Loading Demo Debug</title>
    <link rel="stylesheet" href="/browser/css/design-system.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Loading Demo Debug Tool</h1>
            <p>Debug and analyze module loading behavior patterns</p>
        </div>
        
        <nav class="nav">
            <a href="/" class="nav-link">üè† Home</a>
            <a href="/loading-demo" class="nav-link">‚ö° Loading Demo</a>
            <a href="/browser/debug.html" class="nav-link">üîß Main Debug</a>
            <a href="https://github.com/vishal83/JSModulesExploration" target="_blank" class="nav-link">üìö GitHub</a>
        </nav>
        
        <div class="demo-section">
            <h2>üîç Loading Pattern Analysis</h2>
            <p>Debug different module loading patterns and their behavior:</p>
            
            <button onclick="debugStaticImports()" class="btn btn-primary">Debug Static Imports</button>
            <button onclick="debugDynamicImports()" class="btn btn-success">Debug Dynamic Imports</button>
            <button onclick="debugLoadingOrder()" class="btn btn-secondary">Debug Loading Order</button>
            
            <div id="loading-debug-output" class="output">
üîç Loading Debug Tool Ready!

Select a debug option above to analyze module loading patterns.
            </div>
        </div>
        
        <div class="demo-section">
            <h2>üìä Performance Analysis</h2>
            <p>Measure and compare loading performance:</p>
            
            <button onclick="measureSequentialLoading()" class="btn btn-primary">Measure Sequential</button>
            <button onclick="measureParallelLoading()" class="btn btn-success">Measure Parallel</button>
            <button onclick="compareLoadingMethods()" class="btn btn-outline">Compare Methods</button>
            
            <div id="performance-debug-output" class="output">
üìä Performance analysis tools ready for testing module loading speeds.
            </div>
        </div>
        
        <div class="info-box">
            <h3>üõ†Ô∏è Debug Capabilities</h3>
            <ul>
                <li><strong>Static Import Analysis:</strong> Examine how static imports work</li>
                <li><strong>Dynamic Import Debugging:</strong> Test runtime module loading</li>
                <li><strong>Loading Order:</strong> Understand module execution order</li>
                <li><strong>Performance Measurement:</strong> Compare loading strategies</li>
                <li><strong>Network Analysis:</strong> Monitor HTTP requests</li>
            </ul>
        </div>
    </div>
    
    <script type="module">
        console.log('‚ö° Loading debug tool initialized');
        
        window.debugStaticImports = function() {
            const output = document.getElementById('loading-debug-output');
            output.className = 'output info';
            
            let debug = 'üì¶ Static Imports Debug Analysis:\n\n';
            debug += 'üîç This page uses static imports at the top level:\n';
            debug += '  ‚Ä¢ All imports are hoisted\n';
            debug += '  ‚Ä¢ Modules load in parallel\n';
            debug += '  ‚Ä¢ Execution waits for all imports\n\n';
            
            debug += 'üåê Network Behavior:\n';
            debug += '  ‚Ä¢ Browser requests all modules immediately\n';
            debug += '  ‚Ä¢ HTTP/2 multiplexing enables parallel downloads\n';
            debug += '  ‚Ä¢ Module resolution happens at parse time\n\n';
            
            debug += '‚ö° Execution Order:\n';
            debug += '  1. HTML parsed, <script type="module"> found\n';
            debug += '  2. JavaScript parsed, imports discovered\n';
            debug += '  3. All imports requested in parallel\n';
            debug += '  4. Script execution waits for imports\n';
            debug += '  5. Script body executes\n\n';
            
            debug += 'üí° Check Network tab to see the actual requests!';
            
            output.textContent = debug;
        };
        
        window.debugDynamicImports = async function() {
            const output = document.getElementById('loading-debug-output');
            output.className = 'output info';
            output.textContent = 'üîÑ Testing dynamic imports...';
            
            try {
                let debug = 'üîÑ Dynamic Imports Debug Results:\n\n';
                
                // Test dynamic import timing
                console.time('Dynamic Import Test');
                const startTime = performance.now();
                
                const mathModule = await import('/esm/math-utils.js');
                
                const endTime = performance.now();
                console.timeEnd('Dynamic Import Test');
                
                debug += `‚è±Ô∏è Timing Results:\n`;
                debug += `  ‚Ä¢ Import duration: ${(endTime - startTime).toFixed(2)}ms\n`;
                debug += `  ‚Ä¢ Module: /esm/math-utils.js\n`;
                debug += `  ‚Ä¢ Exports loaded: ${Object.keys(mathModule).length}\n\n`;
                
                debug += `üîç Dynamic Import Characteristics:\n`;
                debug += `  ‚Ä¢ Returns a Promise\n`;
                debug += `  ‚Ä¢ Loads at runtime (not parse time)\n`;
                debug += `  ‚Ä¢ Can be conditional\n`;
                debug += `  ‚Ä¢ Enables code splitting\n\n`;
                
                debug += `üß™ Test Results:\n`;
                debug += `  ‚Ä¢ add(10, 5) = ${mathModule.add(10, 5)}\n`;
                debug += `  ‚Ä¢ Module cached: ${performance.getEntriesByName('/esm/math-utils.js').length > 0}\n\n`;
                
                debug += `üí° Dynamic imports are perfect for:\n`;
                debug += `  ‚Ä¢ Lazy loading\n`;
                debug += `  ‚Ä¢ Conditional loading\n`;
                debug += `  ‚Ä¢ Code splitting\n`;
                debug += `  ‚Ä¢ Reducing initial bundle size`;
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `‚ùå Dynamic import debug failed: ${error.message}`;
            }
        };
        
        window.debugLoadingOrder = async function() {
            const output = document.getElementById('loading-debug-output');
            output.className = 'output info';
            output.textContent = 'üìã Testing loading order...';
            
            try {
                let debug = 'üìã Module Loading Order Debug:\n\n';
                
                debug += 'üîÑ Loading modules in sequence to observe order:\n';
                
                console.log('üì¶ Loading math module...');
                const mathStart = performance.now();
                await import('/esm/math-utils.js');
                const mathEnd = performance.now();
                debug += `  1. Math module: ${(mathEnd - mathStart).toFixed(2)}ms\n`;
                
                console.log('üë• Loading user module...');
                const userStart = performance.now();
                await import('/esm/user-service.js');
                const userEnd = performance.now();
                debug += `  2. User module: ${(userEnd - userStart).toFixed(2)}ms\n`;
                
                console.log('‚öôÔ∏è Loading config module...');
                const configStart = performance.now();
                await import('/esm/config.js');
                const configEnd = performance.now();
                debug += `  3. Config module: ${(configEnd - configStart).toFixed(2)}ms\n\n`;
                
                debug += '‚ö° Parallel Loading Test:\n';
                const parallelStart = performance.now();
                await Promise.all([
                    import('/esm/math-utils.js'),
                    import('/esm/user-service.js'),
                    import('/esm/config.js')
                ]);
                const parallelEnd = performance.now();
                debug += `  ‚Ä¢ Parallel time: ${(parallelEnd - parallelStart).toFixed(2)}ms\n\n`;
                
                debug += 'üîç Key Observations:\n';
                debug += '  ‚Ä¢ Second imports of same module are instant (cached)\n';
                debug += '  ‚Ä¢ Parallel loading is faster than sequential\n';
                debug += '  ‚Ä¢ Module instances are singletons\n';
                debug += '  ‚Ä¢ Import order affects execution timing\n\n';
                
                debug += 'üí° Check console for detailed loading logs!';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `‚ùå Loading order debug failed: ${error.message}`;
            }
        };
        
        window.measureSequentialLoading = async function() {
            const output = document.getElementById('performance-debug-output');
            output.className = 'output info';
            output.textContent = 'üìä Measuring sequential loading...';
            
            try {
                const modules = ['/esm/math-utils.js', '/esm/user-service.js', '/esm/config.js'];
                
                console.time('Sequential Loading Measurement');
                const startTime = performance.now();
                
                const results = [];
                for (const modulePath of modules) {
                    const moduleStart = performance.now();
                    await import(modulePath);
                    const moduleEnd = performance.now();
                    results.push({
                        path: modulePath.split('/').pop(),
                        time: moduleEnd - moduleStart
                    });
                }
                
                const totalTime = performance.now() - startTime;
                console.timeEnd('Sequential Loading Measurement');
                
                let debug = 'üìä Sequential Loading Performance:\n\n';
                debug += '‚è±Ô∏è Individual Module Times:\n';
                results.forEach((result, index) => {
                    debug += `  ${index + 1}. ${result.path}: ${result.time.toFixed(2)}ms\n`;
                });
                
                debug += `\nüéØ Total Sequential Time: ${totalTime.toFixed(2)}ms\n\n`;
                
                debug += 'üîç Sequential Characteristics:\n';
                debug += '  ‚Ä¢ Each module waits for previous to complete\n';
                debug += '  ‚Ä¢ Network requests happen one at a time\n';
                debug += '  ‚Ä¢ Predictable execution order\n';
                debug += '  ‚Ä¢ Higher total latency\n';
                debug += '  ‚Ä¢ Simpler error handling';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `‚ùå Sequential measurement failed: ${error.message}`;
            }
        };
        
        window.measureParallelLoading = async function() {
            const output = document.getElementById('performance-debug-output');
            output.className = 'output info';
            output.textContent = 'üìä Measuring parallel loading...';
            
            try {
                const modules = ['/esm/math-utils.js', '/esm/user-service.js', '/esm/config.js'];
                
                console.time('Parallel Loading Measurement');
                const startTime = performance.now();
                
                await Promise.all(modules.map(path => import(path)));
                
                const totalTime = performance.now() - startTime;
                console.timeEnd('Parallel Loading Measurement');
                
                let debug = 'üìä Parallel Loading Performance:\n\n';
                debug += `üéØ Total Parallel Time: ${totalTime.toFixed(2)}ms\n\n`;
                
                debug += 'üîç Parallel Characteristics:\n';
                debug += '  ‚Ä¢ All modules load simultaneously\n';
                debug += '  ‚Ä¢ Network requests happen concurrently\n';
                debug += '  ‚Ä¢ Utilizes HTTP/2 multiplexing\n';
                debug += '  ‚Ä¢ Lower total latency\n';
                debug += '  ‚Ä¢ Requires Promise.all() coordination\n\n';
                
                debug += 'üåê Network Benefits:\n';
                debug += '  ‚Ä¢ Reduces round-trip delays\n';
                debug += '  ‚Ä¢ Better bandwidth utilization\n';
                debug += '  ‚Ä¢ Ideal for independent modules\n';
                debug += '  ‚Ä¢ Modern browser optimization';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `‚ùå Parallel measurement failed: ${error.message}`;
            }
        };
        
        window.compareLoadingMethods = async function() {
            const output = document.getElementById('performance-debug-output');
            output.className = 'output info';
            output.textContent = 'üìä Comparing loading methods...';
            
            try {
                const modules = ['/esm/math-utils.js', '/esm/user-service.js', '/esm/config.js'];
                
                // Sequential test
                console.time('Sequential Comparison');
                const seqStart = performance.now();
                for (const path of modules) {
                    await import(path);
                }
                const seqTime = performance.now() - seqStart;
                console.timeEnd('Sequential Comparison');
                
                // Wait a bit to avoid interference
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Parallel test  
                console.time('Parallel Comparison');
                const parStart = performance.now();
                await Promise.all(modules.map(path => import(path)));
                const parTime = performance.now() - parStart;
                console.timeEnd('Parallel Comparison');
                
                const improvement = ((seqTime - parTime) / seqTime * 100).toFixed(1);
                
                let debug = 'üìä Loading Method Comparison Results:\n\n';
                debug += '‚ö° Performance Metrics:\n';
                debug += `  ‚Ä¢ Sequential Loading: ${seqTime.toFixed(2)}ms\n`;
                debug += `  ‚Ä¢ Parallel Loading: ${parTime.toFixed(2)}ms\n`;
                debug += `  ‚Ä¢ Performance Gain: ${improvement}% faster\n\n`;
                
                debug += 'üéØ Winner: ';
                if (parTime < seqTime) {
                    debug += 'Parallel Loading ‚úÖ\n\n';
                } else {
                    debug += 'Sequential Loading (unusual!) ‚ö†Ô∏è\n\n';
                }
                
                debug += 'üìà Analysis:\n';
                debug += `  ‚Ä¢ Time saved: ${(seqTime - parTime).toFixed(2)}ms\n`;
                debug += `  ‚Ä¢ Efficiency ratio: ${(parTime / seqTime).toFixed(2)}x\n`;
                debug += `  ‚Ä¢ Module count: ${modules.length}\n`;
                debug += `  ‚Ä¢ Network optimization: ${parTime < seqTime ? 'Effective' : 'Limited'}\n\n`;
                
                debug += 'üí° Recommendations:\n';
                if (improvement > 20) {
                    debug += '  ‚Ä¢ Use parallel loading for independent modules\n';
                    debug += '  ‚Ä¢ Significant performance benefit observed\n';
                } else {
                    debug += '  ‚Ä¢ Limited performance difference\n';
                    debug += '  ‚Ä¢ Either approach is acceptable\n';
                }
                debug += '  ‚Ä¢ Consider module dependencies\n';
                debug += '  ‚Ä¢ Use sequential for dependent modules';
                
                output.className = 'output success';
                output.textContent = debug;
                
            } catch (error) {
                output.className = 'output error';
                output.textContent = `‚ùå Comparison failed: ${error.message}`;
            }
        };
        
        console.log('‚ö° Loading debug script loaded and ready!');
    </script>
</body>
</html>